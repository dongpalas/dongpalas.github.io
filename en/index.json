[{"content":"형변환 확장 함수 public static class ExtensionMethods { public static int ToInt(this string value, int defaultInteger = 0) { try { if (int.TryParse(value, out int validInteger)) return validInteger; else return defaultInteger; } catch { return defaultInteger; } } public static decimal ToDecimal(this string value, decimal defaultDecimal = 0.0M) { try { if (decimal.TryParse(value, out decimal validDecimal)) return validDecimal; else return defaultDecimal; } catch { return defaultDecimal; } } public static double ToDouble(this string value, double defaultDouble = 0.0D) { try { if (double.TryParse(value, out double validDouble)) // Out variables return validDouble; else return defaultDouble; } catch { return defaultDouble; } } } ","description":"","id":0,"section":"posts","tags":null,"title":"Csharp Default Extension Function","uri":"https://dongpalas.github.io/en/posts/csharp-default-extension-function/"},{"content":"The in, ref, and out Modifiers   ref는 메서드에 의해 수정될 수 있음을 명시하는데 사용된다.\n  in은 메서드에 의해 수정될 수 없음을 명시하는데 사용된다.\n  out은 메서드에 의해 수정될 것 있음을 명시하는데 사용된다.\n  ref와 in는 메서드에 전달되기 전에 초기화 되어야 합니다. out 한정자는 초기화할 필요가 없고 일반적으로 메서드에서 사용되기 전에 초기화 되지 않습니다.\nout 한정자 out 한정자를 사용하면 새 인스턴스를 할당하여 메서드 외부에서 반영할 수 있다. class ReferenceTypeExample { static void Enroll(ref Student student) { // With ref, all three lines below alter the student variable outside the method. student.Enrolled = true; student = new Student(); student.Enrolled = false; } static void Main() { var student = new Student { Name = \u0026quot;Susan\u0026quot;, Enrolled = false }; Enroll(ref student); // student.Name is now null since a value was not passed when declaring new Student() in the Enroll method // student.Enrolled is now false due to the ref modifier } } public class Student { public string Name {get;set;} public bool Enrolled {get;set;} } ","description":"","id":1,"section":"posts","tags":null,"title":"Using in Out Ref With Parameters","uri":"https://dongpalas.github.io/en/posts/using-in-out-ref-with-parameters/"}]